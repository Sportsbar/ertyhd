using EmployeePortal.API.Middleware;
using Microsoft.Extensions.Primitives;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Net;
using System.Security.Claims;
using System;
using System.Linq;
//using CCC.DBModel;
//using CCC.Tokenization.CustomException;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;

namespace EmployeePortal.API.Helpers
{
    public class TokenHelper
    {
        private const string SCOPE = "scp";

        private const char SPACE = ' ';

        private const string Token_Validate_SERVER_URL = "TokenValidateServerUrl";

        private const string CLAIM_NAME = "sub";

        private const string AUTHORIZATION_HEADER_KEY = "Authorization";

        private const string BEARER = "Bearer ";

        private const char SLASH = '/';

        private const string INVALID_TOKEN_ERROR_CODE = "ER401";

        private const string INVALID_TOKEN_ERROR_MESSAGE = "Invalid Token";

        private const string TOKEN_EXPIRED_ERROR_CODE = "ER401";

        private const string TOKEN_EXPIRED_ERROR_MESSAGE = "Token has been expired";

        private const string INVALID_TOKEN_ISSUER = "Invalid token issuer";

        private const string USERDOES_NOT_EXIST = "User Does Not exits";

        private const string URL_DOES_NOT_EXISTS = "URL Does Not exits";

        public AuthData PrepareAPIRequestObject(HttpRequest request)
        {
            if (request == null || request.Headers == null)
            {
                return null;
            }

            string text = string.Join("/", request.Path.ToUriComponent().Split(new char[1] { '/' }).Take(4)
                .ToList());
            if (!text.Last().Equals('/'))
            {
                text += "/";
            }

            string accessToken = string.Empty;
            if (request.Headers.ContainsKey("Authorization"))
            {
                StringValues value = default(StringValues);
                if (request.Headers.TryGetValue("Authorization", out value))
                {
                    accessToken = value.FirstOrDefault((string v) => v.StartsWith("Bearer "));
                }
            }

            AuthData RequestAuthData = new AuthData
            {
                Url = text,
                RequestType = request.Method.ToString(),
                AccessToken = accessToken
            };
            ValidateAccessToken(RequestAuthData);
            //UserProfile userProfile = crispContext.UserProfile.Where((UserProfile x) => x.Username == RequestAuthData.UserName && x.IsActive == true).FirstOrDefault();
            //if (userProfile == null)
            //{
            //    throw new ObjectNotFoundException("User Does Not exits");
            //}

            //RequestAuthData.UserId = userProfile.UserId;
            return RequestAuthData;
        }

        public AuthData ValidateAccessToken(AuthData authData)
        {
            authData.AccessToken = ExtractAccessToken(authData);
            JwtSecurityTokenHandler jwtSecurityTokenHandler = new JwtSecurityTokenHandler();
            if (!jwtSecurityTokenHandler.CanReadToken(authData.AccessToken))
            {
                throw new Exception("Invalid Token" + HttpStatusCode.Unauthorized);
            }

            JwtSecurityToken jwtSecurityToken = null;
            try
            {
                jwtSecurityToken = jwtSecurityTokenHandler.ReadToken(authData.AccessToken) as JwtSecurityToken;
            }
            catch (Exception)
            {
                throw new Exception("InvalidAccessTokenVoilationException Token" + HttpStatusCode.Unauthorized);
            }

            if (jwtSecurityToken == null)
            {
                throw new Exception("InvalidAccessTokenVoilationException Token" + HttpStatusCode.Unauthorized);
            }

            if (IsSSOUser(jwtSecurityToken))
            {
                ValidateClaimsPrincipal(authData, jwtSecurityTokenHandler);
            }

            return ExtractPayload(jwtSecurityToken, authData);
        }

        private bool IsSSOUser(JwtSecurityToken jwtToken)
        {
            JwtPayload payload = jwtToken.Payload;
            if (payload.Keys.Contains("unique_name"))
            {
                payload["unique_name"].ToString();
                return true;
            }

            return false;
        }

        private AuthData ExtractPayload(JwtSecurityToken jwtToken, AuthData authData)
        {
            JwtPayload payload = jwtToken.Payload;
            if (payload.Keys.Contains("clientId"))
            {
                authData.Client = payload["clientId"].ToString();
            }

            if (payload.Keys.Contains("userName"))
            {
                authData.UserName = payload["userName"].ToString();
            }

            if (payload.Keys.Contains("unique_name"))
            {
                authData.UserName = payload["unique_name"].ToString();
            }

            if (payload.Keys.Contains("name"))
            {
                authData.Name = payload["name"].ToString();
            }

            if (payload.Keys.Contains("roleid"))
            {
                int.TryParse(payload["roleid"].ToString(), out var result);
                authData.RoleId = result;
            }

            return authData;
        }

        private static string ExtractAccessToken(AuthData authData)
        {
            if (!string.IsNullOrEmpty(authData.AccessToken) && Enumerable.Contains(authData.AccessToken, ' '))
            {
                string[] array = authData.AccessToken.Split(new char[1] { ' ' });
                if (array.Length != 0 && !string.IsNullOrEmpty(array[1]))
                {
                    return array[1];
                }
            }
            throw new Exception("InvalidAccessTokenVoilationException Token" + HttpStatusCode.Unauthorized);
            //throw new InvalidAccessTokenVoilationException("ER401", "Invalid Token", HttpStatusCode.Unauthorized);
        }

        private static void ValidateClaimsPrincipal(AuthData authData, JwtSecurityTokenHandler handler)
        {
            handler.InboundClaimTypeMap.Clear();
             //string validIssuer = configuration.GetSection("AppSettings:TokenValidateServerUrl").Get<string>();
            string validIssuer = string.Empty;
            try
            {
                SecurityToken validatedToken;
                ClaimsPrincipal claimsPrincipal = handler.ValidateToken(authData.AccessToken, new TokenValidationParameters
                {
                    ValidateAudience = false,
                    ValidIssuer = validIssuer,
                    ValidateIssuerSigningKey = false,
                    ValidateLifetime = true,
                    SignatureValidator = (string t, TokenValidationParameters param) => new JwtSecurityToken(t),
                    NameClaimType = "sub"
                }, out validatedToken);
                if (!claimsPrincipal.Claims.Any((Claim c) => c.Type == "scp"))
                {
                    throw new Exception("InvalidAccessTokenVoilationException Token" + HttpStatusCode.Unauthorized);
                    //throw new InvalidAccessTokenVoilationException("ER401", "Invalid Token", HttpStatusCode.Unauthorized);
                }
            }
            catch (SecurityTokenExpiredException)
            {
                throw new Exception("InvalidAccessTokenVoilationException Token" + HttpStatusCode.Unauthorized);
                //throw new AccessTokenExpiredVoilationException("ER401", "Token has been expired", HttpStatusCode.Unauthorized);
            }
            //catch (InvalidTokenIssuerException)
            //{
            //    throw new InvalidTokenIssuerException("Invalid token issuer");
            //}
            //catch (ObjectNotFoundException)
            //{
            //    throw new ObjectNotFoundException("URL Does Not exits");
            //}
        }
    }
}
